основные программы умножения матриц:
- band.c - реализация ленточного (striped) алгоритма умножения матриц.
  матрица A разбивается по строкам между процессами, матрица B полностью копируется на все процессы.
  каждый процесс умножает свои строки A на всю матрицу B.

- cannon.c - реализация алгоритма Кэннона для умножения матриц.
  использует декартову топологию процессов и циклическую перестановку блоков матриц.
  требует чтобы количество процессов было квадратом целого числа и размер матрицы делился на размер сетки.

вспомогательные скрипты для тестирования:
- run_band.sh - базовый скрипт для запуска ленточного алгоритма с заданными параметрами
- compare.sh - прямое сравнение двух алгоритмов на конкретных конфигурациях
- full_test.sh - полное тестирование всех комбинаций размеров и процессов
- final_test.sh - финальное тестирование гарантированно работающих конфигураций

алгоритм работы:

1. компиляция программ:
   mpicc band.c -o band
   mpicc cannon.c -o cannon -lm

2. запуск тестов (в порядке рекомендуемого выполнения):
   - быстрое сравнение: ./compare.sh
   - базовое тестирование: sbatch run_band.sh <процессы> <размер>
   - полное тестирование: sbatch full_test.sh
   - финальное тестирование: sbatch final_test.sh

3. как работают алгоритмы:

ленточный алгоритм (band):
- процесс 0 создает случайные матрицы A и B
- матрица A разбивается по строкам с помощью MPI_Scatter
- матрица B рассылается всем процессам с помощью MPI_Bcast
- каждый процесс умножает свои строки A на всю матрицу B
- результаты собираются с помощью MPI_Gather

алгоритм Кэннона (cannon):
- создается квадратная сетка процессов (декартова топология)
- матрицы A и B разбиваются на блоки и распределяются по процессам
- выполняется начальная перестановка блоков (skewing)
- в q итераций выполняются:
  - локальное умножение блоков
  - циклический сдвиг блоков A влево и блоков B вверх
- результаты собираются на процессе 0

особенности алгоритмов:
- ленточный: прост в реализации, но требует много памяти (каждый процесс хранит всю матрицу B)
- кэннона: более сложный, но эффективнее использует коммуникации, требует специфичных условий

получаемые данные:
- время выполнения умножения матриц для разных алгоритмов
- производительность в MFLOPS (миллионах операций с плавающей точкой в секунду)
- сравнение масштабируемости двух алгоритмов
- данные о влиянии размера матрицы и количества процессов на производительность

анализ результатов:
- позволяет определить какой алгоритм эффективнее для разных конфигураций
- показывает как масштабируются алгоритмы с увеличением количества процессов
- демонстрирует trade-off между простотой реализации и эффективностью коммуникаций
- помогает выбрать оптимальный алгоритм для конкретной задачи
