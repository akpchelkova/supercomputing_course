основные программы:
- message_exchange.c - оригинальная версия программы из задания 3, использующая 
  отдельные операции MPI_Send и MPI_Recv для обмена сообщениями.

- message_exchange_sendrecv.c - модифицированная версия программы, использующая 
  комбинированную операцию MPI_Sendrecv для одновременной отправки и приема данных.

вспомогательные скрипты:
- compile_both.sh - компилирует обе версии программы
- job_original.sh - скрипт для запуска оригинальной версии на кластере
- run_mpi8_comprehensive.sh - комплексный скрипт для сравнения двух версий 
  в разных условиях (один узел vs разные узлы)

алгоритм работы:

1. компиляция программ:
   ./compile_both.sh

2. запуск тестов:
   - комплексное сравнение: ./run_mpi8_comprehensive.sh
   - отдельный запуск оригинальной версии: sbatch job_original.sh

3. как работают программы:
   - тестируют производительность обмена сообщениями для разных размеров (1 байт - 4 МБ)
   - измеряют время обмена и пропускную способность
   - проверяют корректность переданных данных
   - тестируют внутриУЗЛОВые и межУЗЛОВые коммуникации

4. ключевые различия между версиями:

оригинальная версия (Send/Recv):
- использует отдельные вызовы MPI_Send и MPI_Recv
- последовательная отправка и прием
- может приводить к deadlock'ам если не аккуратно спроектирована
- более гибкая но требует больше вызовов mpi

модифицированная версия (Sendrecv):
- использует комбинированную операцию MPI_Sendrecv
- одновременная отправка и прием в одной атомарной операции
- избегает проблем с deadlock'ами
- может быть более эффективной благодаря оптимизациям mpi

5. тестируемые сценарии:
   - внутриУЗЛОВые коммуникации (быстрые, через shared memory)
   - межУЗЛОВые коммуникации (медленные, через сеть)
   - разные размеры сообщений (от маленьких до больших)

получаемые данные:
- время обмена сообщениями для каждого размера
- пропускная способность канала связи
- сравнение производительности Send/Recv vs Sendrecv
- данные о внутриУЗЛОВых и межУЗЛОВых коммуникациях
- процент улучшения при использовании Sendrecv

анализ результатов:
- позволяет определить когда Sendrecv более эффективен чем отдельные Send/Recv
- показывает влияние размера сообщений на эффективность разных подходов
- демонстрирует разницу в производительности внутриУЗЛОВых и межУЗЛОВых коммуникаций
- помогает выбрать оптимальный метод передачи данных для конкретного сценария

ожидаемые результаты:
- Sendrecv обычно более эффективен для избежания deadlock'ов
- для маленьких сообщений разница может быть незначительной
- для больших сообщений и межУЗЛОВых коммуникаций Sendrecv может давать преимущество
- атомарность Sendrecv упрощает разработку параллельных программ
